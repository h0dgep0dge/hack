CALL

@Filename.VM$ABC // Generated by the self.new_label method, matches the one at the end
D=A
PUSHD // Stores return address on the stack
@LCL
PUSHM // Stores local vars pointer on the stack
@ARG
PUSHM // Stores arguments pointer on the stack
@THIS
PUSHM // Stores THIS pointer on the stack
@THAT
PUSHM // Stores THAT pointer on the stack

@{argc + 5}
D=A
@SP
D=M-D // Subtract the size of the stack frame plus the number of arguments from the stack pointer
@ARG
M=D // Set the arguments pointer to the start of the arguments for the callee

@SP
D=M
@LCL
M=D // Set local pointer to the current stack pointer

@{instr.arg1}
0;JMP

(Filename.VM$ABC) // Generated by the self.new_label method



FUNCTION

({instr.arg1})
@0
D=A
PUSHD
PUSHD // times the number of locals
PUSHD


RETURN

POPTOD
@13
M=D // Move top value from stack to the memory pointed to by ARG

@ARG
D=M
@14
M=D // Store the value of ARG+1 in temporary memory

@LCL
D=M
@SP
M=D // Move the stack pointer to the current value of LCL

POPTOD
@THAT
M=D // Restore THAS off the stack

POPTOD
@THIS
M=D // Restore THIT off the stack

POPTOD
@ARG
M=D // Restore ARG off the stack

POPTOD
@LCL
M=D // Restore LCL off the stack

POPTOD
@15
M=D // Pop the return address off the stack and place it in temporary memory

@14
D=M
@SP
M=D // Pull the old ARG out of memory, set the stack pointer to that value

@13
D=M
PUSHD

@15
A=M
0;JMP // Pull the return address out of memory, and jump to it







